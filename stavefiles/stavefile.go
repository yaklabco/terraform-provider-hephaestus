// Copyright (c) 2025 Yaklab Co.
// SPDX-License-Identifier: MIT

//go:build stave

// Build script for terraform-provider-hephaestus.
// Uses stave for task automation with pretty output.
package main

import (
	"cmp"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/yaklabco/stave/pkg/sh"
	"github.com/yaklabco/stave/pkg/st"
	"github.com/yaklabco/stave/pkg/stave/prettylog"
	"github.com/yaklabco/stave/pkg/ui"
)

func init() {
	logHandler := prettylog.SetupPrettyLogger(os.Stdout)
	if st.Debug() {
		logHandler.SetLevel(log.DebugLevel)
	}
}

// *********************************************************************
// * Aliases maps target aliases to their implementations.
// *

var Aliases = map[string]interface{}{}

// *
// *********************************************************************

// *********************************************************************
// * Default target
// *

var Default = All

// *
// *********************************************************************

// *********************************************************************
// * Default namespace
// *

// All runs init, test:all, and build in sequence.
func All() error {
	st.Deps(Init, Test.All)
	st.Deps(Build)

	return nil
}

// Init installs required tools and sets up modules.
func Init() {
	st.Deps(Prereq.Brew, Prereq.Go)
}

// Build compiles the provider binary.
func Build() error {
	st.Deps(Init)

	outputln("Building provider binary...")
	return sh.RunV("go", "build", "-o", "terraform-provider-hephaestus", ".")
}

// Clean removes build artifacts.
func Clean() error {
	outputln("Cleaning build artifacts...")

	if err := sh.Rm("terraform-provider-hephaestus"); err != nil {
		return err
	}

	return sh.Rm("dist")
}

// *
// * Default namespace
// *********************************************************************

// *********************************************************************
// * Prereq namespace
// *

type Prereq st.Namespace

// Go tidies modules and runs go generate.
func (Prereq) Go() error {
	st.Deps(Prereq.Brew)

	if err := sh.Run("go", "mod", "tidy"); err != nil {
		return err
	}

	if err := sh.Run("go", "generate", "./..."); err != nil {
		return err
	}

	return sh.Run("go", "mod", "tidy")
}

// Brew installs tools from Brewfile via Homebrew.
func (Prereq) Brew() error {
	return sh.Run("brew", "bundle", "--file=Brewfile")
}

// *
// * Prereq namespace
// *********************************************************************

// *********************************************************************
// * Lint namespace
// *

type Lint st.Namespace

// All runs lint:go after lint:markdown and init.
func (Lint) All() {
	st.Deps(Init, Lint.Markdown, Lint.Go)
}

// Markdown runs markdownlint-cli2 on all tracked Markdown files.
// Excludes docs/ directory as those are auto-generated by terraform-plugin-docs.
func (Lint) Markdown() error {
	st.Deps(Init)

	markdownFilesList, err := sh.Output("git", "ls-files", "--cached", "--others", "--exclude-standard", "--", "*.md")
	if err != nil {
		return err
	}

	markdownFilesList = strings.TrimSpace(markdownFilesList)
	if markdownFilesList == "" {
		log.Info("No Markdown files found to lint. Skipping.")
		return nil
	}

	var files []string
	for _, s := range strings.Split(markdownFilesList, "\n") {
		// Skip auto-generated docs from terraform-plugin-docs
		if s != "" && !strings.HasPrefix(s, "docs/") {
			files = append(files, s)
		}
	}

	if len(files) == 0 {
		log.Info("No Markdown files to lint after exclusions. Skipping.")
		return nil
	}

	return sh.Run("markdownlint-cli2", files...)
}

// Go runs golangci-lint with auto-fix enabled.
func (Lint) Go() error {
	st.Deps(Init)
	out, err := sh.Output("golangci-lint", "run", "--fix", "--allow-parallel-runners", "--build-tags='!ignore'")
	if err != nil {
		titleStyle, blockStyle := ui.GetBlockStyles()
		outputln(titleStyle.Render("golangci-lint output"))
		outputln(blockStyle.Render(out))
		outputln("")
		return err
	}

	return nil
}

// *
// * Lint namespace
// *********************************************************************

// *********************************************************************
// * Test namespace
// *

type Test st.Namespace

// All aggregate target runs lint:all and test:go.
func (Test) All() error {
	st.Deps(Init)

	if !isQuietMode() {
		outputln("Running tests (test:all: lint:all, test:go)")
	}

	startTime := time.Now()

	st.Deps(Lint.All, Test.Go)

	if !isQuietMode() {
		outputf("All tests ran successfully (%s)\n", time.Since(startTime).Round(time.Millisecond))
	}

	return nil
}

// Go runs Go tests with coverage and produces coverage.out and coverage.html.
func (Test) Go() error {
	st.Deps(Init)

	nCoresStr := cmp.Or(os.Getenv("STAVE_NUM_PROCESSORS"), "1")

	if err := sh.RunV(
		"go", "tool", "gotestsum", "-f", "pkgname-and-test-fails",
		"--",
		"-v", "-p", nCoresStr, "-parallel", nCoresStr, "./...", "-count", "1",
		"-coverprofile=coverage.out", "-covermode=atomic",
	); err != nil {
		return err
	}

	return sh.Run("go", "tool", "cover", "-html=coverage.out", "-o", "coverage.html")
}

// Unit runs unit tests only (no acceptance tests).
func (Test) Unit() error {
	st.Deps(Init)

	outputln("Running unit tests...")
	return sh.RunV("go", "test", "-v", "-short", "./...")
}

// Acc runs acceptance tests (requires TF_ACC=1).
func (Test) Acc() error {
	st.Deps(Init)

	outputln("Running acceptance tests...")
	outputln("Note: Requires actual infrastructure")

	return sh.RunWithV(
		map[string]string{"TF_ACC": "1"},
		"go", "test", "-v", "./internal/provider/...",
	)
}

// *
// * Test namespace
// *********************************************************************

// *********************************************************************
// * Provider namespace
// *

type Provider st.Namespace

// Install builds and installs the provider for local development.
func (Provider) Install() error {
	st.Deps(Build)

	dir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("get working directory: %w", err)
	}

	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("get home dir: %w", err)
	}

	terraformrc := filepath.Join(home, ".terraformrc")
	expectedContent := fmt.Sprintf(`provider_installation {
  dev_overrides {
    "yaklab/hephaestus" = "%s"
  }
  direct {}
}
`, dir)

	existing, err := os.ReadFile(terraformrc)
	if err != nil || !strings.Contains(string(existing), "yaklab/hephaestus") {
		outputf("Creating %s with dev_overrides...\n", terraformrc)
		const configFilePerm = 0o644
		if err := os.WriteFile(terraformrc, []byte(expectedContent), configFilePerm); err != nil {
			return fmt.Errorf("write terraformrc: %w", err)
		}
	}

	binaryPath := filepath.Join(dir, "terraform-provider-hephaestus")
	outputln("")
	outputf("Provider installed: %s\n", binaryPath)
	outputln("")
	outputln("Usage:")
	outputln("  cd ../cluster && tofu apply  # Uses local provider")
	outputln("")
	outputln("Note: With dev_overrides, 'tofu init' is not required.")

	return nil
}

// BuildAll builds the provider for multiple platforms.
func (Provider) BuildAll() error {
	st.Deps(Init)

	platforms := []struct {
		goos   string
		goarch string
	}{
		{"linux", "amd64"},
		{"linux", "arm64"},
		{"darwin", "amd64"},
		{"darwin", "arm64"},
	}

	outputln("Building provider for all platforms...")

	const distDirPerm = 0o755
	if err := os.MkdirAll("dist", distDirPerm); err != nil {
		return fmt.Errorf("create dist dir: %w", err)
	}

	for _, p := range platforms {
		outName := fmt.Sprintf("terraform-provider-hephaestus_%s_%s", p.goos, p.goarch)
		outPath := filepath.Join("dist", outName)

		outputf("  Building %s/%s...\n", p.goos, p.goarch)

		if err := sh.RunWith(
			map[string]string{
				"GOOS":        p.goos,
				"GOARCH":      p.goarch,
				"CGO_ENABLED": "0",
			},
			"go", "build", "-o", outPath, ".",
		); err != nil {
			return fmt.Errorf("build %s/%s: %w", p.goos, p.goarch, err)
		}
	}

	outputln("")
	outputln("Binaries written to: dist/")
	return nil
}

// Docs generates provider documentation using tfplugindocs.
func (Provider) Docs() error {
	st.Deps(Init)

	outputln("Generating documentation...")
	return sh.RunV("go", "run", "github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs@latest", "generate")
}

// Release builds release artifacts using goreleaser (dry-run).
func (Provider) Release() error {
	st.Deps(Init)

	outputln("Building release (dry run)...")
	return sh.RunV("goreleaser", "release", "--snapshot", "--clean")
}

// *
// * Provider namespace
// *********************************************************************

// *********************************************************************
// * Debug namespace
// *

type Debug st.Namespace

// Parallelism prints parallelism environment variables (debugging utility).
func (Debug) Parallelism() {
	outputf("STAVE_NUM_PROCESSORS=%q\n", os.Getenv("STAVE_NUM_PROCESSORS"))
	outputf("GOMAXPROCS=%q\n", os.Getenv("GOMAXPROCS"))
}

// Info prints provider and environment information.
func (Debug) Info() error {
	dir, err := os.Getwd()
	if err != nil {
		return err
	}

	outputln("=== Provider Info ===")
	outputf("Directory: %s\n", dir)
	outputln("Binary: terraform-provider-hephaestus")
	outputf("Go Version: %s\n", runtime.Version())
	outputf("OS/Arch: %s/%s\n", runtime.GOOS, runtime.GOARCH)

	binary := filepath.Join(dir, "terraform-provider-hephaestus")
	if info, err := os.Stat(binary); err == nil {
		outputf("Binary Size: %.2f MB\n", float64(info.Size())/(1024*1024))
		outputf("Binary Modified: %s\n", info.ModTime().Format("2006-01-02 15:04:05"))
	} else {
		outputln("Binary: not built")
	}

	return nil
}

// *
// * Debug namespace
// *********************************************************************

// *********************************************************************
// * utility functions
// *

// outputf writes a formatted string to stdout.
func outputf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stdout, format, args...)
}

// outputln writes a string to stdout with a trailing newline.
func outputln(s string) {
	_, _ = fmt.Fprintln(os.Stdout, s)
}

// isQuietMode returns true if output should be suppressed (CI environments).
func isQuietMode() bool {
	if os.Getenv("STAVE_QUIET") == "1" {
		return true
	}
	ciVars := []string{"CI", "GITHUB_ACTIONS", "GITLAB_CI", "JENKINS_URL", "CIRCLECI", "BUILDKITE"}
	for _, v := range ciVars {
		if os.Getenv(v) != "" {
			return true
		}
	}
	return false
}

// *
// * utility functions
// *********************************************************************
